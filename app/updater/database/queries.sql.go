// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkPageExists = `-- name: CheckPageExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      "UpdateHistory"
    WHERE
      "hash" = ?1)
`

func (q *Queries) CheckPageExists(ctx context.Context, hash string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkPageExists, hash)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getUpdateHistory = `-- name: GetUpdateHistory :one
SELECT
  checkedOn, hash, pageURL
FROM
  "UpdateHistory"
WHERE
  "pageURL" = ?1
`

func (q *Queries) GetUpdateHistory(ctx context.Context, pageurl string) (UpdateHistory, error) {
	row := q.db.QueryRowContext(ctx, getUpdateHistory, pageurl)
	var i UpdateHistory
	err := row.Scan(&i.CheckedOn, &i.Hash, &i.PageURL)
	return i, err
}

const selectAllBios = `-- name: SelectAllBios :many
SELECT
  "url",
  "bio"
FROM
  "Artist"
`

type SelectAllBiosRow struct {
	Url string
	Bio sql.NullString
}

func (q *Queries) SelectAllBios(ctx context.Context) ([]SelectAllBiosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllBios)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllBiosRow
	for rows.Next() {
		var i SelectAllBiosRow
		if err := rows.Scan(&i.Url, &i.Bio); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE
  "Album"
SET
  "name" = COALESCE(?1, "name"),
  "year" = COALESCE(?2, "year"),
  "imageUrl" = COALESCE(?3, "imageUrl")
WHERE
  "artistUrl" = ?4
  AND "name" = ?5
RETURNING
  "name",
  "year",
  "rating",
  "artistUrl",
  "imageUrl",
  "pageURL"
`

type UpdateAlbumParams struct {
	Newname   sql.NullString
	Year      sql.NullInt64
	Imageurl  sql.NullString
	ArtistUrl string
	Name      string
}

func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, updateAlbum,
		arg.Newname,
		arg.Year,
		arg.Imageurl,
		arg.ArtistUrl,
		arg.Name,
	)
	var i Album
	err := row.Scan(
		&i.Name,
		&i.Year,
		&i.Rating,
		&i.ArtistUrl,
		&i.ImageUrl,
		&i.PageURL,
	)
	return i, err
}

const updateArtistNameAndImage = `-- name: UpdateArtistNameAndImage :one
UPDATE
  "Artist"
SET
  "name" = COALESCE(?1, "name"),
  "imageUrl" = COALESCE(?2, "imageUrl")
WHERE
  "url" = ?3
RETURNING
  "url",
  "name",
  "bio",
  "imageUrl",
  "lastModified"
`

type UpdateArtistNameAndImageParams struct {
	Name     sql.NullString
	Imageurl sql.NullString
	Url      string
}

func (q *Queries) UpdateArtistNameAndImage(ctx context.Context, arg UpdateArtistNameAndImageParams) (Artist, error) {
	row := q.db.QueryRowContext(ctx, updateArtistNameAndImage, arg.Name, arg.Imageurl, arg.Url)
	var i Artist
	err := row.Scan(
		&i.Url,
		&i.Name,
		&i.Bio,
		&i.ImageUrl,
		&i.LastModified,
	)
	return i, err
}

const updateBio = `-- name: UpdateBio :exec
UPDATE
  "Artist"
SET
  "bio" = ?1
WHERE
  "url" = ?2
`

type UpdateBioParams struct {
	Bio sql.NullString
	Url string
}

func (q *Queries) UpdateBio(ctx context.Context, arg UpdateBioParams) error {
	_, err := q.db.ExecContext(ctx, updateBio, arg.Bio, arg.Url)
	return err
}

const upsertAlbum = `-- name: UpsertAlbum :exec
INSERT INTO "Album" ("name", "year", "rating", "artistUrl", "imageUrl", "pageURL")
  VALUES (?1, ?2, ?3, ?4, ?5, ?6)
ON CONFLICT ("artistUrl", "name")
  DO UPDATE SET
    "year" = excluded."year", "rating" = excluded."rating", "imageUrl" = excluded."imageUrl",
      "pageURL" = excluded."pageURL"
`

type UpsertAlbumParams struct {
	Name      string
	Year      sql.NullInt64
	Rating    float64
	ArtistUrl string
	ImageUrl  sql.NullString
	PageURL   string
}

func (q *Queries) UpsertAlbum(ctx context.Context, arg UpsertAlbumParams) error {
	_, err := q.db.ExecContext(ctx, upsertAlbum,
		arg.Name,
		arg.Year,
		arg.Rating,
		arg.ArtistUrl,
		arg.ImageUrl,
		arg.PageURL,
	)
	return err
}

const upsertArtist = `-- name: UpsertArtist :exec
INSERT INTO "Artist" ("url", "name", "bio", "imageUrl", "lastModified")
  VALUES (?1, ?2, ?3, ?4, DATETIME('now'))
ON CONFLICT ("url")
  DO UPDATE SET
    "name" = excluded."name", "bio" = excluded."bio", "imageUrl" = excluded."imageUrl",
      "lastModified" = excluded."lastModified"
`

type UpsertArtistParams struct {
	Url      string
	Name     string
	Bio      sql.NullString
	ImageUrl sql.NullString
}

func (q *Queries) UpsertArtist(ctx context.Context, arg UpsertArtistParams) error {
	_, err := q.db.ExecContext(ctx, upsertArtist,
		arg.Url,
		arg.Name,
		arg.Bio,
		arg.ImageUrl,
	)
	return err
}

const upsertUpdateHistory = `-- name: UpsertUpdateHistory :one
INSERT INTO "UpdateHistory" ("checkedOn", "hash", "pageURL")
  VALUES (?1, ?2, ?3)
ON CONFLICT ("pageURL")
  DO UPDATE SET
    "hash" = excluded."hash", "checkedOn" = excluded."checkedOn"
  WHERE
    excluded."hash" != "UpdateHistory"."hash"
  RETURNING
    "checkedOn", "hash", "pageURL"
`

type UpsertUpdateHistoryParams struct {
	CheckedOn time.Time
	Hash      string
	PageURL   string
}

func (q *Queries) UpsertUpdateHistory(ctx context.Context, arg UpsertUpdateHistoryParams) (UpdateHistory, error) {
	row := q.db.QueryRowContext(ctx, upsertUpdateHistory, arg.CheckedOn, arg.Hash, arg.PageURL)
	var i UpdateHistory
	err := row.Scan(&i.CheckedOn, &i.Hash, &i.PageURL)
	return i, err
}
